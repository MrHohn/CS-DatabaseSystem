package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    // private Iterator<Tuple> _outerPage = null;
    // private Iterator<Tuple> _innerPage = null;

    private Tuple _outerRecent = null;
    private Tuple _innerRecent = null;

    // varable for SMJ
    // store the last Tuple for duplicate detection
    private Tuple _innerLast = null;

    private int _joinType = 0;
    private int _numMatches = 0;
    private int _numComp = 0;
  
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        //IMPLEMENT THIS

        _predicate = p;
        _outerRelation = child1;
        _innerRelation = child2;
    }

    public void setJoinAlgorithm(int joinAlgo){
	   _joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
    	//IMPLEMENT THIS

        // create new tupledesc
        TupleDesc joinedTupleDesc = TupleDesc.combine(_outerRelation.getTupleDesc(), _innerRelation.getTupleDesc());
    	return joinedTupleDesc;
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
        //IMPLEMENT THIS

        _outerRelation.open();
        _innerRelation.open();
        // _outerPage = null;
        // _innerPage = null;
        _outerRecent = null;
        _innerRecent = null;
        _numMatches = 0;
        _numComp = 0;
        _innerLast = null;
    }

    public void close() {
        //IMPLEMENT THIS

        _outerRelation.close();
        _innerRelation.close();
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
        //IMPLEMENT THIS

        _outerRelation.rewind();
        _innerRelation.rewind();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
	switch(_joinType){
	case SNL: return SNL_readNext();
	case PNL: return PNL_readNext();
	case BNL: return BNL_readNext();
	case SMJ: return SMJ_readNext();
	case HJ: return HJ_readNext();
	default: return SNL_readNext();
	}
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
        //IMPLEMENT THIS

        try {
            // if first time enter
            if (_outerRecent == null && _innerRecent == null) {
                // read the first outer tuple
                if (!_outerRelation.hasNext() || !_innerRelation.hasNext()) {
                    // return null if anyone is empty
                    return null;
                }
                _outerRecent = _outerRelation.next();
            }

            Tuple res = null;
            // find next joined tuple until touch the end
            while (res == null) {
                // if touch the end of inner loop
                if (!_innerRelation.hasNext()) {
                    // if touch the end of outer loop
                    if (!_outerRelation.hasNext()) {
                        return null;
                    }
                    // rewind the inner iterator
                    _innerRelation.rewind();
                    // step to the next outer tuple
                    _outerRecent = _outerRelation.next();
                }

                // now try to match
                _innerRecent = _innerRelation.next();
                res = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
            }

            return res;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
        //IMPLEMENT THIS (EXTRA CREDIT ONLY)

        try {
            // if first time enter
            if (_outerRecent == null && _innerRecent == null) {
                // return null if anyone is empty
                if (!_outerRelation.hasNext() || !_innerRelation.hasNext()) {
                    return null;
                }
                // read the first inner tuple
                _innerRecent = _innerRelation.next();
            }

            Tuple res = null;
            while (res == null) {
                // if touch the end of a page in outer relation
                // but not the end of inner relation
                if (!((SeqScan)_outerRelation).moreInCurrentPage() && _innerRelation.hasNext()) {
                    // rewind the page iterator for outer loop
                    ((SeqScan)_outerRelation).rewindPageIterator();
                    // read the next inner tuple
                    _innerRecent = _innerRelation.next();
                }
                // if touch the end of a page in outer relation
                // also the end of inner relation
                // but not the end of outer relation
                else if (!((SeqScan)_outerRelation).moreInCurrentPage() && !_innerRelation.hasNext() && _outerRelation.hasNext()) {
                    // rewind the inner iterator
                    _innerRelation.rewind();
                    // re-read the first inner tuple
                    _innerRecent = _innerRelation.next();
                }
                // if touch the end of a page in outer relation
                // also the end of inner relation
                // also the end of outer relation
                else if (!((SeqScan)_outerRelation).moreInCurrentPage() && !_innerRelation.hasNext() && !_outerRelation.hasNext()) {
                    // join finished, return null
                    return null;
                }

                // now try to match
                _outerRecent = _outerRelation.next();
                res = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
            }

            return res;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }


    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
	
        //IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
        
        // Because we assume the input files(relations) are sorted
        // We only present merge phase in this function

        try {
            // flag to indicate the new arrival
            boolean newArrival = false;
            // if first time enter
            if (_outerRecent == null && _innerRecent == null) {
                if (!_outerRelation.hasNext() || !_innerRelation.hasNext()) {
                    // return null if anyone is empty
                    return null;
                }
                // read the first tuples
                _outerRecent = _outerRelation.next();
                _innerRecent = _innerRelation.next();
                newArrival = true;
            }

            Tuple res = null;
            while (res == null) {
                // if value in inner tuple is smaller
                if (_predicate.getLeftField(_outerRecent).compare(Predicate.Op.GREATER_THAN, _predicate.getRightField(_innerRecent))) {
                    // return null if reach the end
                    if (!_innerRelation.hasNext()) {
                        return null;
                    }
                    // move inner iterator
                    _innerRecent = _innerRelation.next();
                }
                // if value in outer tuple is smaller
                else if (_predicate.getLeftField(_outerRecent).compare(Predicate.Op.LESS_THAN, _predicate.getRightField(_innerRecent))) {
                    if (!_outerRelation.hasNext()) {
                        // return null if reach the end
                        return null;
                    }
                    // move outer iterator and check if duplicate
                    SMJ_moveOuterIterator();
                }

                // if values are the same, but not new arrival
                if (!newArrival) {
                    // return null if both reach the end
                    if (!_innerRelation.hasNext() && !_outerRelation.hasNext()) {
                        return null;
                    }
                    // need to move iterators

                    // if inner reach the end but outer not
                    if (!_innerRelation.hasNext()) {
                        // move outer iterator and check if duplicate
                        SMJ_moveOuterIterator();
                    }
                    // if inner not reach the end
                    else {
                        _innerRecent = _innerRelation.next();
                    }                    
                }
                // if have the same value and new arrival, join them
                else {
                    res = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
                    // save current match inner tuple if needed
                    if (_innerLast == null) {
                        _innerLast = _innerRecent;
                    }
                }

                newArrival = true;
            }

            return res;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private void SMJ_moveOuterIterator() throws TransactionAbortedException, DbException {
        try {
            // move outer iterator and check if duplicate
            Tuple temp = _outerRecent;
            _outerRecent = _outerRelation.next();
            // if outer next duplicate, may need to reset inner
            if (_predicate.getLeftField(temp).equals(_predicate.getLeftField(_outerRecent))) {
                if (_innerLast != null) {
                    // reverse inner back to last matched
                    boolean calledPrevious = false;
                    while (_innerRecent != _innerLast) {
                        _innerRecent = ((SeqScan)_innerRelation).previous();
                        calledPrevious = true;
                    }
                    if (calledPrevious) {
                        // remeber to call next again to reset position
                        _innerRelation.next();
                    }
                }
            }
            // otherwise erase the inner copy
            else {
                _innerLast = null;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
        //IMPLEMENT THIS

        // increment for comparison
        ++_numComp;
        // if match, return the combined tuple
        if (_predicate.filter(outer, inner)) {
            ++_numMatches;
            TupleDesc outerDesc = outer.getTupleDesc();
            TupleDesc innerDesc = inner.getTupleDesc();
            // create new tuple
            Tuple joinedTuple = new Tuple(tupledesc);
            // set the fields
            for (int i = 0; i < outerDesc.numFields(); ++i) {
                joinedTuple.setField(i, outer.getField(i));
            }
            for (int i = 0; i < innerDesc.numFields(); ++i) {
                joinedTuple.setField(i + outerDesc.numFields(), inner.getField(i));
            }
            return joinedTuple;
        }
        // return null if not match
        return null;
    }

    public int getNumMatches(){
	return _numMatches;
    }
    public int getNumComp(){
	return _numComp;
    }
}
